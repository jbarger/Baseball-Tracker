<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Baseball Tracker — Cage Annotation Tool</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #1a1a2e;
    color: #e0e0e0;
    overflow: hidden;
    height: 100vh;
  }

  /* --- Top toolbar --- */
  .toolbar {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 16px;
    background: #16213e;
    border-bottom: 1px solid #0f3460;
    flex-wrap: wrap;
  }
  .toolbar h1 {
    font-size: 14px;
    color: #00d4ff;
    margin-right: 16px;
    white-space: nowrap;
  }
  .tool-group {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 0 8px;
    border-left: 1px solid #0f3460;
  }
  .tool-group:first-of-type { border-left: none; }
  .tool-group label {
    font-size: 11px;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-right: 4px;
  }
  .btn {
    padding: 6px 14px;
    border: 1px solid #0f3460;
    background: #16213e;
    color: #e0e0e0;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.15s;
  }
  .btn:hover { background: #0f3460; border-color: #00d4ff; }
  .btn.active { background: #0f3460; border-color: #00d4ff; color: #00d4ff; }
  .btn.danger { border-color: #e94560; }
  .btn.danger:hover { background: #e94560; color: white; }
  .btn.success { border-color: #00d4ff; }
  .btn.success:hover { background: #00d4ff; color: #1a1a2e; }

  /* --- Main canvas area --- */
  .canvas-area {
    position: relative;
    flex: 1;
    overflow: hidden;
    height: calc(100vh - 90px);
    display: flex;
    justify-content: center;
    align-items: center;
    background: #111;
  }
  canvas {
    cursor: crosshair;
    image-rendering: auto;
    position: absolute;
    left: 0;
    top: 0;
  }

  /* --- Side panel --- */
  .side-panel {
    position: fixed;
    right: 0;
    top: 45px;
    bottom: 0;
    width: 340px;
    background: #16213e;
    border-left: 1px solid #0f3460;
    overflow-y: auto;
    padding: 12px;
    font-size: 12px;
    z-index: 10;
  }
  .side-panel h3 {
    font-size: 13px;
    color: #00d4ff;
    margin: 12px 0 6px;
    border-bottom: 1px solid #0f3460;
    padding-bottom: 4px;
  }
  .side-panel h3:first-child { margin-top: 0; }
  .coord-list {
    font-family: 'Courier New', monospace;
    font-size: 11px;
    background: #0d1b2a;
    padding: 8px;
    border-radius: 4px;
    margin: 4px 0;
    max-height: 200px;
    overflow-y: auto;
  }
  .coord-list .point {
    padding: 2px 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .coord-list .point:hover { background: #1a2a4a; }
  .coord-list .point .remove {
    cursor: pointer;
    color: #e94560;
    font-size: 14px;
    padding: 0 4px;
  }
  .json-output {
    font-family: 'Courier New', monospace;
    font-size: 11px;
    background: #0d1b2a;
    color: #00ff88;
    padding: 8px;
    border-radius: 4px;
    white-space: pre-wrap;
    word-break: break-all;
    margin: 4px 0;
    max-height: 300px;
    overflow-y: auto;
    border: 1px solid #0f3460;
    user-select: all;
  }

  /* --- Ball tracking panel styles --- */
  .ball-track-panel { display: none; }
  .ball-track-panel.visible { display: block; }
  .frame-nav {
    display: flex;
    align-items: center;
    gap: 6px;
    margin: 8px 0;
  }
  .frame-nav .btn { padding: 4px 10px; font-size: 11px; }
  .frame-nav .frame-num {
    font-family: 'Courier New', monospace;
    font-size: 14px;
    color: #00d4ff;
    flex: 1;
    text-align: center;
  }
  .ball-point-list {
    font-family: 'Courier New', monospace;
    font-size: 11px;
    background: #0d1b2a;
    padding: 8px;
    border-radius: 4px;
    margin: 4px 0;
    max-height: 350px;
    overflow-y: auto;
  }
  .ball-point-list .entry {
    padding: 2px 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    border-radius: 2px;
  }
  .ball-point-list .entry:hover { background: #1a2a4a; }
  .ball-point-list .entry.current { background: #0f3460; color: #00d4ff; }
  .ball-point-list .entry.marked { color: #00ff88; }
  .ball-point-list .entry.unmarked { color: #666; }
  .ball-point-list .entry .remove {
    cursor: pointer;
    color: #e94560;
    font-size: 13px;
    padding: 0 4px;
    visibility: hidden;
  }
  .ball-point-list .entry.marked .remove { visibility: visible; }
  .ball-point-list .entry.marked:hover .remove { visibility: visible; }
  .progress-bar {
    height: 4px;
    background: #0d1b2a;
    border-radius: 2px;
    margin: 6px 0;
    overflow: hidden;
  }
  .progress-bar .fill {
    height: 100%;
    background: #00d4ff;
    transition: width 0.2s;
  }

  /* --- Stream panel --- */
  .stream-panel {
    border: 1px solid #0f3460;
    border-radius: 4px;
    padding: 8px;
    margin-bottom: 12px;
    background: #0d1b2a;
  }
  .stream-panel h3 {
    font-size: 12px;
    color: #00d4ff;
    margin: 0 0 6px;
    display: flex;
    align-items: center;
    gap: 6px;
    cursor: pointer;
    user-select: none;
  }
  .stream-panel h3 .toggle-arrow {
    font-size: 10px;
    transition: transform 0.2s;
  }
  .stream-panel h3 .toggle-arrow.open { transform: rotate(90deg); }
  .stream-panel .stream-body { display: none; }
  .stream-panel .stream-body.open { display: block; }
  .stream-radio-group {
    display: flex;
    gap: 8px;
    margin: 4px 0 8px;
  }
  .stream-radio-group label {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 12px;
    cursor: pointer;
    color: #ccc;
  }
  .stream-radio-group input[type="radio"] { margin: 0; cursor: pointer; }
  .stream-options {
    margin: 4px 0 8px;
    padding: 6px;
    background: #16213e;
    border-radius: 3px;
    font-size: 11px;
  }
  .stream-options label { color: #888; font-size: 11px; display: block; margin-bottom: 2px; }
  .stream-options select, .stream-options input[type="text"] {
    width: 100%;
    padding: 3px 6px;
    background: #0d1b2a;
    color: #e0e0e0;
    border: 1px solid #0f3460;
    border-radius: 3px;
    font-size: 11px;
    margin-bottom: 4px;
  }
  .stream-status-dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #555;
    margin-right: 4px;
  }
  .stream-status-dot.active {
    background: #00ff88;
    box-shadow: 0 0 4px #00ff88;
  }
  .stream-btn-row {
    display: flex;
    gap: 4px;
    margin-top: 6px;
  }
  .stream-btn-row .btn { flex: 1; padding: 5px 8px; font-size: 11px; }

  /* --- Status bar --- */
  .status-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: #0d1b2a;
    padding: 4px 16px;
    font-size: 11px;
    color: #888;
    display: flex;
    gap: 24px;
    z-index: 20;
    border-top: 1px solid #0f3460;
  }
  .status-bar .highlight { color: #00d4ff; }

  /* --- Drop zone overlay --- */
  .drop-zone {
    position: absolute;
    inset: 0;
    background: rgba(0, 212, 255, 0.1);
    border: 3px dashed #00d4ff;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 100;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
  }
  .drop-zone.visible { opacity: 1; }
  .drop-zone p { font-size: 18px; color: #00d4ff; }
  .drop-zone small { font-size: 12px; color: #888; margin-top: 8px; }

  /* --- No-image placeholder --- */
  .placeholder {
    text-align: center;
    color: #555;
  }
  .placeholder h2 { font-size: 20px; margin-bottom: 12px; color: #888; }
  .placeholder p { font-size: 14px; line-height: 1.8; }
  .placeholder code {
    background: #0d1b2a;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 12px;
    color: #00d4ff;
  }
</style>
</head>
<body>

<!-- Toolbar -->
<div class="toolbar">
  <h1>&#9918; Cage Annotator</h1>

  <div class="tool-group">
    <label>Mode</label>
    <button class="btn active" id="btn-roi" onclick="setMode('roi')">1: ROI Polygon</button>
    <button class="btn" id="btn-machine" onclick="setMode('machine')">2: Machine BBox</button>
    <button class="btn" id="btn-home" onclick="setMode('home')">3: Home Plate</button>
    <button class="btn" id="btn-ball" onclick="setMode('ball')">4: Ball Tracking</button>
    <button class="btn" id="btn-calibrate" onclick="setMode('calibrate')">5: Calibrate</button>
  </div>

  <div class="tool-group">
    <label>Actions</label>
    <button class="btn danger" onclick="clearCurrent()">Clear Current</button>
    <button class="btn danger" onclick="clearAll()">Clear All</button>
    <button class="btn" onclick="undoLast()">Undo</button>
  </div>

  <div class="tool-group">
    <label>Image</label>
    <button class="btn" onclick="document.getElementById('file-input').click()">Load Image</button>
    <input type="file" id="file-input" accept="image/*" style="display:none" onchange="loadImage(event)">
    <button class="btn" onclick="loadFromVideo()">Load Video Frame</button>
    <input type="file" id="video-input" accept="video/*" style="display:none" onchange="extractFrame(event)">
    <button class="btn" id="btn-load-stills" onclick="document.getElementById('stills-input').click()" style="display:none">Load Stills</button>
    <input type="file" id="stills-input" accept="image/*" multiple style="display:none" onchange="loadStills(event)">
  </div>

  <div class="tool-group">
    <label>Zoom</label>
    <button class="btn" onclick="zoomBy(1.3)" title="Zoom in (+)">+</button>
    <button class="btn" onclick="zoomBy(1/1.3)" title="Zoom out (-)">-</button>
    <button class="btn" onclick="resetView()" title="Fit to screen (0)">Fit</button>
  </div>

  <div class="tool-group">
    <label>Export</label>
    <button class="btn success" onclick="copyConfig()">&#128203; Copy Config</button>
    <button class="btn success" onclick="downloadConfig()">&#128190; Download JSON</button>
  </div>
</div>

<!-- Main Area -->
<div class="canvas-area" id="canvas-area">
  <div class="drop-zone" id="drop-zone">
    <p>Drop image(s) here</p>
    <small>Single image for cage annotation, or multiple stills for ball tracking</small>
  </div>

  <div class="placeholder" id="placeholder">
    <h2>Drag &amp; drop a reference frame to get started</h2>
    <p>
      Or click <strong>Load Image</strong> to open <code>output/reference_frame.jpg</code><br>
      Or click <strong>Load Video Frame</strong> to grab frame 0 from a video file
    </p>
    <p style="margin-top:12px; font-size:13px; color:#888;">
      <strong>Ball Tracking mode (key 4):</strong> Load multiple still frames,<br>
      then click on the ball in each frame to build a trajectory.
    </p>
    <p style="margin-top:20px; font-size:12px; color:#555;">
      Generate a reference frame with:<br>
      <code>python calibrate_cage.py /videos/clip.mov /output/reference_frame.jpg</code>
    </p>
    <p style="margin-top:12px; font-size:12px; color:#555;">
      <strong>Zoom:</strong> Scroll wheel &bull; <strong>Pan:</strong> Space+drag or Middle-click drag
    </p>
  </div>

  <canvas id="canvas" style="display:none"></canvas>
</div>

<!-- Hidden img for MJPEG stream rendering -->
<img id="streamImg" style="display:none" crossorigin="anonymous">

<!-- Side Panel -->
<div class="side-panel" id="side-panel">
  <!-- Stream panel (always visible, collapsible) -->
  <div class="stream-panel" id="stream-panel">
    <h3 onclick="toggleStreamPanel()">
      <span class="toggle-arrow" id="stream-toggle-arrow">&#9654;</span>
      <span class="stream-status-dot" id="stream-dot"></span>
      Live Camera
      <span id="stream-fps-badge" style="margin-left:auto; font-size:10px; color:#888;"></span>
    </h3>
    <div class="stream-body" id="stream-body">
      <div class="stream-radio-group">
        <label><input type="radio" name="stream-source" value="off" checked onchange="onStreamSourceChange()"> Off</label>
        <label><input type="radio" name="stream-source" value="usb" onchange="onStreamSourceChange()"> USB Camera</label>
        <label><input type="radio" name="stream-source" value="rtmp" onchange="onStreamSourceChange()"> RTMP Stream</label>
      </div>

      <!-- USB options -->
      <div class="stream-options" id="stream-usb-options" style="display:none;">
        <label>Camera device</label>
        <select id="stream-usb-device">
          <option value="0">Device 0</option>
        </select>
        <button class="btn" onclick="streamDetectCameras()" style="width:100%; margin-top:2px; padding:3px; font-size:10px;">Detect Cameras</button>
      </div>

      <!-- RTMP options -->
      <div class="stream-options" id="stream-rtmp-options" style="display:none;">
        <label>RTMP URL</label>
        <input type="text" id="stream-rtmp-url" value="rtmp://localhost:1935/live/stream" placeholder="rtmp://host:port/app/key">
      </div>

      <!-- Controls -->
      <div class="stream-btn-row">
        <button class="btn success" id="stream-start-btn" onclick="streamStart()" disabled>Start</button>
        <button class="btn danger" id="stream-stop-btn" onclick="streamStop()" disabled>Stop</button>
        <button class="btn" id="stream-snapshot-btn" onclick="streamSnapshot()" disabled>Snapshot</button>
      </div>

      <!-- Detection toggle -->
      <div style="margin-top:6px;">
        <label style="font-size:11px; cursor:pointer; display:flex; align-items:center; gap:4px;">
          <input type="checkbox" id="stream-detection-toggle" checked onchange="toggleDetection(this.checked)">
          Detection Overlay
          <span id="stream-det-fps" style="margin-left:auto; font-size:10px; color:#888;"></span>
        </label>
      </div>

      <!-- Status -->
      <div id="stream-status-text" style="font-size:10px; color:#888; margin-top:4px;"></div>
    </div>
  </div>

  <!-- Cage annotation panels (visible in roi/machine/home modes) -->
  <div id="cage-panels">
    <h3>&#128308; ROI Polygon <span id="roi-count">(0 points)</span></h3>
    <p style="font-size:11px; color:#888; margin-bottom:4px;">Click to add points along cage net boundary. <strong>Ctrl+click</strong> near a point to drag it. Right-click to undo last.</p>
    <div class="coord-list" id="roi-list">No points yet</div>

    <h3>&#128998; Machine BBox <span id="machine-status">(not set)</span></h3>
    <p style="font-size:11px; color:#888; margin-bottom:4px;">Click &amp; drag a rectangle around the pitching machine.</p>
    <div class="coord-list" id="machine-info">Not set</div>

    <h3>&#11044; Home Plate <span id="home-status">(not set)</span></h3>
    <p style="font-size:11px; color:#888; margin-bottom:4px;">Click to place &bull; Ctrl+click to move</p>
    <div class="coord-list" id="home-info">Not set</div>

    <h3>&#128196; Config Output</h3>
    <p style="font-size:11px; color:#888; margin-bottom:4px;">Copy this into <code>cage_config.json</code></p>
    <div class="json-output" id="json-output">{ }</div>
  </div>

  <!-- Ball tracking panel (visible in ball mode) -->
  <div id="ball-panel" class="ball-track-panel">
    <h3>&#9918; Ball Tracking</h3>
    <p style="font-size:11px; color:#888; margin-bottom:4px;">
      Load stills with <strong>Load Stills</strong> button or drag &amp; drop multiple images.<br>
      Click on the ball in each frame. Use <strong>&larr; &rarr;</strong> arrow keys or buttons to navigate.<br>
      Press <strong>S</strong> to skip (no ball visible). <strong>Ctrl+click</strong> to move a placed point.<br>
      <strong>Scroll</strong> to zoom &bull; <strong>Space+drag</strong> to pan &bull; Frames auto-advance after marking.
    </p>

    <div class="frame-nav">
      <button class="btn" onclick="ballPrevFrame()" title="Previous frame (Left arrow)">&#9664; Prev</button>
      <span class="frame-num" id="ball-frame-label">No frames loaded</span>
      <button class="btn" onclick="ballNextFrame()" title="Next frame (Right arrow)">Next &#9654;</button>
    </div>

    <div class="progress-bar"><div class="fill" id="ball-progress" style="width:0%"></div></div>
    <p style="font-size:11px; color:#888;" id="ball-stats">0 / 0 frames marked</p>

    <h3>Marked Positions</h3>
    <div class="ball-point-list" id="ball-point-list">No frames loaded</div>

    <h3 style="margin-top:12px;">&#128196; Ball Trajectory JSON</h3>
    <p style="font-size:11px; color:#888; margin-bottom:4px;">Frame number &rarr; [x, y] coordinates</p>
    <div class="json-output" id="ball-json-output">{ }</div>

    <div style="margin-top:8px; display:flex; gap:6px;">
      <button class="btn success" onclick="copyBallJSON()">&#128203; Copy JSON</button>
      <button class="btn success" onclick="downloadBallJSON()">&#128190; Download</button>
    </div>
  </div>

  <!-- Calibrate panel (visible in calibrate mode) -->
  <div id="calibrate-panel" class="ball-track-panel">
    <h3>&#128247; Camera Calibration</h3>
    <p style="font-size:11px; color:#888; margin-bottom:8px;">
      Configure camera model, cage measurements, and run auto-calibration
      from ground truth data. Toggle <strong>3D Overlay</strong> to preview
      the projected pitch line.
    </p>

    <h3>Camera Model</h3>
    <select id="cal-camera-model" style="width:100%; padding:4px; margin-bottom:6px; background:#0d1b2a; color:#e0e0e0; border:1px solid #0f3460; border-radius:4px;" onchange="onCameraModelChange()">
      <option value="">-- Select Camera --</option>
    </select>
    <div id="cal-camera-info" style="font-size:11px; color:#888; margin-bottom:8px;"></div>

    <h3>Ball Type</h3>
    <select id="cal-ball-type" style="width:100%; padding:4px; margin-bottom:8px; background:#0d1b2a; color:#e0e0e0; border:1px solid #0f3460; border-radius:4px;">
      <option value="yellow_dimple">Yellow Dimple Ball (2.85")</option>
      <option value="white_regulation">White Regulation (2.9")</option>
      <option value="softball">Softball (3.82")</option>
    </select>

    <h3>Cage Measurements</h3>
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:4px; font-size:12px; margin-bottom:8px;">
      <label style="color:#888;">Mound distance (ft)</label>
      <input type="number" id="cal-mound-dist" value="60" step="1" style="width:100%; padding:2px 4px; background:#0d1b2a; color:#e0e0e0; border:1px solid #0f3460; border-radius:3px;">
      <label style="color:#888;">Camera height (ft)</label>
      <input type="number" id="cal-cam-height" value="5.0" step="0.5" style="width:100%; padding:2px 4px; background:#0d1b2a; color:#e0e0e0; border:1px solid #0f3460; border-radius:3px;">
      <label style="color:#888;">Behind plate (ft)</label>
      <input type="number" id="cal-cam-behind" value="2.0" step="0.5" style="width:100%; padding:2px 4px; background:#0d1b2a; color:#e0e0e0; border:1px solid #0f3460; border-radius:3px;">
      <label style="color:#888;">Release height (ft)</label>
      <input type="number" id="cal-release-h" value="3.5" step="0.25" style="width:100%; padding:2px 4px; background:#0d1b2a; color:#e0e0e0; border:1px solid #0f3460; border-radius:3px;">
      <label style="color:#888;">Strike zone (ft)</label>
      <input type="number" id="cal-strike-h" value="2.5" step="0.25" style="width:100%; padding:2px 4px; background:#0d1b2a; color:#e0e0e0; border:1px solid #0f3460; border-radius:3px;">
      <label style="color:#888;">Sign speed (mph)</label>
      <input type="number" id="cal-sign-speed" value="47.5" step="0.5" style="width:100%; padding:2px 4px; background:#0d1b2a; color:#e0e0e0; border:1px solid #0f3460; border-radius:3px;">
    </div>

    <h3>Actions</h3>
    <div style="display:flex; flex-direction:column; gap:4px; margin-bottom:8px;">
      <button class="btn" onclick="calLoadConfig()">Load Config from Server</button>
      <button class="btn success" onclick="calSaveConfig()">Save Config to Server</button>
      <button class="btn" onclick="calRunAutoCalibrate()" id="cal-run-btn">Run Auto-Calibrate</button>
      <label style="font-size:12px; display:flex; align-items:center; gap:6px; cursor:pointer;">
        <input type="checkbox" id="cal-overlay-toggle" onchange="draw()"> Show 3D Overlay
      </label>
    </div>

    <h3>Results</h3>
    <div id="cal-results" style="font-size:11px; color:#888; background:#0d1b2a; padding:6px; border-radius:4px; max-height:200px; overflow-y:auto; font-family:monospace; white-space:pre-wrap;">
      No calibration run yet.
    </div>

    <h3 style="margin-top:8px;">Optimized Parameters</h3>
    <div class="json-output" id="cal-json-output">{ }</div>
    <div style="margin-top:6px; display:flex; gap:6px;">
      <button class="btn success" onclick="calCopyParams()">Copy JSON</button>
    </div>
  </div>
</div>

<!-- Status Bar -->
<div class="status-bar">
  <span>Mode: <span class="highlight" id="status-mode">ROI Polygon</span></span>
  <span>Mouse: <span class="highlight" id="status-mouse">—</span></span>
  <span>Image: <span class="highlight" id="status-image">none</span></span>
  <span>Zoom: <span class="highlight" id="status-zoom">100%</span></span>
  <span id="status-frame-info" style="display:none">Frame: <span class="highlight" id="status-frame">—</span></span>
</div>

<script>
// ============================================================
// STATE
// ============================================================
let mode = 'roi';          // 'roi' | 'machine' | 'home' | 'ball'
let img = null;            // loaded Image object
let imgW = 0, imgH = 0;

// Annotation data (in image pixel coordinates)
let roiPoints = [];        // [[x,y], ...]
let machineBBox = null;    // [x1, y1, x2, y2] or null
let homePoint = null;      // [x, y] or null

// Ball tracking data
let ballFrames = [];           // Array of { frameNum, img, fileName }
let ballPositions = {};        // { frameNum: [x, y] } — marked positions
let ballSkipped = {};          // { frameNum: true } — explicitly skipped frames
let ballCurrentIdx = 0;        // index into ballFrames[]

// Drag state for machine bbox
let dragging = false;
let dragStart = null;
let dragEnd = null;

// Drag state for moving ROI/home/ball points (Ctrl+click)
let movingPointIdx = -1;    // index into roiPoints being dragged, or -1
let movingHome = false;     // true if dragging home plate point
let movingBall = false;     // true if dragging ball point
const GRAB_RADIUS = 15;     // screen-pixel radius for grabbing a point

// Canvas / view state — virtual camera
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let viewZoom = 1;      // zoom factor: 1 = 1 image px = 1 screen px
let panX = 0;           // image-space X coordinate at canvas center
let panY = 0;           // image-space Y coordinate at canvas center

// Pan state
let isPanning = false;
let panMouseStartX = 0, panMouseStartY = 0;
let panStartPanX = 0, panStartPanY = 0;
let spaceHeld = false;

// Live stream state
let streamActive = false;
const streamImg = document.getElementById('streamImg');
let streamAnimFrame = null;  // requestAnimationFrame ID
let streamImgReady = false;  // true once streamImg has loaded at least one frame

// ============================================================
// COORDINATE TRANSFORMS
// ============================================================
// Image pixel coords → canvas screen coords
function i2s(ix, iy) {
  return [
    (ix - panX) * viewZoom + canvas.width / 2,
    (iy - panY) * viewZoom + canvas.height / 2,
  ];
}

// Canvas screen coords → image pixel coords
function s2i(sx, sy) {
  return [
    (sx - canvas.width / 2) / viewZoom + panX,
    (sy - canvas.height / 2) / viewZoom + panY,
  ];
}

// Mouse event → image pixel coords (clamped)
function canvasToImage(e) {
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const [ix, iy] = s2i(sx, sy);
  return [Math.round(Math.max(0, Math.min(ix, imgW))), Math.round(Math.max(0, Math.min(iy, imgH)))];
}

// Mouse event → raw screen coords on canvas
function canvasScreenCoords(e) {
  const rect = canvas.getBoundingClientRect();
  return [e.clientX - rect.left, e.clientY - rect.top];
}

// ============================================================
// MODE SWITCHING
// ============================================================
function setMode(m) {
  mode = m;
  document.querySelectorAll('.toolbar .btn').forEach(b => {
    if (b.id === 'btn-' + m) b.classList.add('active');
    else if (b.id.startsWith('btn-')) b.classList.remove('active');
  });
  const names = { roi: 'ROI Polygon', machine: 'Machine BBox', home: 'Home Plate', ball: 'Ball Tracking', calibrate: 'Calibrate' };
  document.getElementById('status-mode').textContent = names[m];

  // Toggle panel visibility
  const isCage = (m !== 'ball' && m !== 'calibrate');
  document.getElementById('cage-panels').style.display = isCage ? 'block' : 'none';
  document.getElementById('ball-panel').className = (m === 'ball') ? 'ball-track-panel visible' : 'ball-track-panel';
  document.getElementById('calibrate-panel').className = (m === 'calibrate') ? 'ball-track-panel visible' : 'ball-track-panel';

  // Toggle stills button visibility
  document.getElementById('btn-load-stills').style.display = (m === 'ball') ? '' : 'none';

  // Toggle frame info in status bar
  document.getElementById('status-frame-info').style.display = (m === 'ball') ? '' : 'none';

  // In ball mode, show current ball frame
  if (m === 'ball' && ballFrames.length > 0) {
    showBallFrame(ballCurrentIdx);
  } else {
    draw();
  }
}

// ============================================================
// IMAGE LOADING
// ============================================================
function loadImage(event) {
  const file = event.target.files[0];
  if (file) loadFile(file);
}

function loadFromVideo() {
  document.getElementById('video-input').click();
}

function extractFrame(event) {
  const file = event.target.files[0];
  if (!file) return;
  const url = URL.createObjectURL(file);
  const video = document.createElement('video');
  video.src = url;
  video.muted = true;
  video.onloadeddata = () => {
    video.currentTime = 0;
  };
  video.onseeked = () => {
    const c = document.createElement('canvas');
    c.width = video.videoWidth;
    c.height = video.videoHeight;
    const cx = c.getContext('2d');
    cx.drawImage(video, 0, 0);
    c.toBlob(blob => {
      loadFile(new File([blob], 'frame_0.jpg', { type: 'image/jpeg' }));
      URL.revokeObjectURL(url);
    }, 'image/jpeg', 0.95);
  };
}

function loadFile(file) {
  const reader = new FileReader();
  reader.onload = e => {
    img = new Image();
    img.onload = () => {
      imgW = img.width;
      imgH = img.height;
      sizeCanvas();
      resetView();
      document.getElementById('placeholder').style.display = 'none';
      canvas.style.display = 'block';
      document.getElementById('status-image').textContent = `${imgW}x${imgH} — ${file.name}`;
      draw();
    };
    img.src = e.target.result;
  };
  reader.readAsDataURL(file);
}

// Load multiple stills for ball tracking
function loadStills(event) {
  const files = Array.from(event.target.files);
  if (files.length === 0) return;
  loadStillFiles(files);
}

function loadStillFiles(files) {
  // Sort files naturally by name (frame_092.png, frame_093.png, ...)
  files.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));

  ballFrames = [];
  ballPositions = {};
  ballSkipped = {};
  ballCurrentIdx = 0;

  let loaded = 0;
  const total = files.length;

  files.forEach((file, idx) => {
    const reader = new FileReader();
    reader.onload = e => {
      const imgObj = new Image();
      imgObj.onload = () => {
        // Extract frame number from filename (e.g., frame_092.png -> 92)
        const match = file.name.match(/(\d+)/);
        const frameNum = match ? parseInt(match[match.length - 1], 10) : idx;

        ballFrames[idx] = {
          frameNum: frameNum,
          img: imgObj,
          fileName: file.name,
          width: imgObj.width,
          height: imgObj.height,
        };

        loaded++;
        if (loaded === total) {
          // All loaded — switch to ball mode and show first frame
          mode = 'ball';
          setMode('ball');
          showBallFrame(0);
          updateBallUI();
        }
      };
      imgObj.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });
}

// Set canvas to fill available viewport area (fixed size, independent of zoom)
function sizeCanvas() {
  const area = document.getElementById('canvas-area');
  const panelWidth = 340;
  const availW = area.clientWidth - panelWidth;
  const availH = area.clientHeight;
  canvas.width = availW;
  canvas.height = availH;
}

// Reset view to fit image on screen, centered
function resetView() {
  if (!imgW || !imgH) return;
  sizeCanvas();
  viewZoom = Math.min(canvas.width / imgW, canvas.height / imgH) * 0.95;
  panX = imgW / 2;
  panY = imgH / 2;
  updateZoomDisplay();
  draw();
}

function updateZoomDisplay() {
  document.getElementById('status-zoom').textContent = `${Math.round(viewZoom * 100)}%`;
}

// Zoom by a factor, optionally centered on a screen point
function zoomBy(factor, centerSX, centerSY) {
  if (centerSX === undefined) {
    centerSX = canvas.width / 2;
    centerSY = canvas.height / 2;
  }
  // Image point under cursor before zoom
  const [ix, iy] = s2i(centerSX, centerSY);
  const newZoom = Math.max(0.05, Math.min(viewZoom * factor, 30));
  // Adjust pan so the image point under cursor stays at the same screen position
  panX = ix - (centerSX - canvas.width / 2) / newZoom;
  panY = iy - (centerSY - canvas.height / 2) / newZoom;
  viewZoom = newZoom;
  updateZoomDisplay();
  draw();
}

// Drag and drop
const canvasArea = document.getElementById('canvas-area');
const dropZone = document.getElementById('drop-zone');

canvasArea.addEventListener('dragover', e => {
  e.preventDefault();
  dropZone.classList.add('visible');
});
canvasArea.addEventListener('dragleave', () => {
  dropZone.classList.remove('visible');
});
canvasArea.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('visible');
  const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
  if (files.length === 0) return;

  if (files.length > 1 || mode === 'ball') {
    // Multiple files -> ball tracking mode
    loadStillFiles(files);
  } else {
    // Single file -> normal image load
    loadFile(files[0]);
  }
});

// ============================================================
// ZOOM & PAN — SCROLL WHEEL + MIDDLE-CLICK/SPACE DRAG
// ============================================================
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const [sx, sy] = canvasScreenCoords(e);
  const factor = e.deltaY < 0 ? 1.15 : 1 / 1.15;
  zoomBy(factor, sx, sy);
}, { passive: false });

// Prevent middle-click scroll on canvas area
canvasArea.addEventListener('mousedown', e => {
  if (e.button === 1) e.preventDefault();
});

// ============================================================
// BALL TRACKING — FRAME NAVIGATION
// ============================================================
function showBallFrame(idx) {
  if (ballFrames.length === 0 || idx < 0 || idx >= ballFrames.length) return;

  const isFirstLoad = (ballCurrentIdx === 0 && idx === 0 && img === null);
  ballCurrentIdx = idx;
  const frame = ballFrames[idx];
  img = frame.img;
  imgW = frame.width;
  imgH = frame.height;

  sizeCanvas();
  document.getElementById('placeholder').style.display = 'none';
  canvas.style.display = 'block';
  document.getElementById('status-image').textContent = `${imgW}x${imgH} — ${frame.fileName}`;
  document.getElementById('status-frame').textContent = `${frame.frameNum} (${idx + 1}/${ballFrames.length})`;

  // Only reset view on first load; preserve zoom/pan when navigating
  if (isFirstLoad) {
    resetView();
  }
  draw();
  updateBallUI();

  // Scroll the list to current entry
  const list = document.getElementById('ball-point-list');
  const entry = list.querySelector(`.entry[data-idx="${idx}"]`);
  if (entry) entry.scrollIntoView({ block: 'nearest' });
}

function ballPrevFrame() {
  if (ballCurrentIdx > 0) showBallFrame(ballCurrentIdx - 1);
}

function ballNextFrame() {
  if (ballCurrentIdx < ballFrames.length - 1) showBallFrame(ballCurrentIdx + 1);
}

function ballSkipFrame() {
  if (ballFrames.length === 0) return;
  const frame = ballFrames[ballCurrentIdx];
  delete ballPositions[frame.frameNum];
  ballSkipped[frame.frameNum] = true;
  if (ballCurrentIdx < ballFrames.length - 1) {
    showBallFrame(ballCurrentIdx + 1);
  } else {
    draw();
    updateBallUI();
  }
}

function ballRemoveMark(frameNum) {
  delete ballPositions[frameNum];
  delete ballSkipped[frameNum];
  draw();
  updateBallUI();
}

function ballGoToFrame(idx) {
  showBallFrame(idx);
}

// ============================================================
// MOUSE EVENTS
// ============================================================

// Find nearest ROI point within grab radius (in screen pixels)
function findNearestPoint(imgX, imgY) {
  let bestIdx = -1, bestDist = Infinity;
  for (let i = 0; i < roiPoints.length; i++) {
    const dx = imgX - roiPoints[i][0];
    const dy = imgY - roiPoints[i][1];
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < bestDist) { bestDist = dist; bestIdx = i; }
  }
  const grabInImagePx = GRAB_RADIUS / viewZoom;
  return bestDist <= grabInImagePx ? bestIdx : -1;
}

// Check if mouse is near ball marker
function isNearBallPoint(imgX, imgY) {
  if (ballFrames.length === 0) return false;
  const frame = ballFrames[ballCurrentIdx];
  const pos = ballPositions[frame.frameNum];
  if (!pos) return false;
  const dx = imgX - pos[0], dy = imgY - pos[1];
  return Math.sqrt(dx * dx + dy * dy) <= GRAB_RADIUS / viewZoom;
}

function updateCursor() {
  if (isPanning || spaceHeld) {
    canvas.style.cursor = isPanning ? 'grabbing' : 'grab';
  } else if (movingPointIdx >= 0 || movingHome || movingBall) {
    canvas.style.cursor = 'grabbing';
  } else {
    canvas.style.cursor = 'crosshair';
  }
}

canvas.addEventListener('mousemove', e => {
  const [sx, sy] = canvasScreenCoords(e);
  const [x, y] = canvasToImage(e);
  document.getElementById('status-mouse').textContent = `(${x}, ${y})`;

  // Panning
  if (isPanning) {
    const dx = sx - panMouseStartX;
    const dy = sy - panMouseStartY;
    panX = panStartPanX - dx / viewZoom;
    panY = panStartPanY - dy / viewZoom;
    draw();
    return;
  }

  // Dragging a ROI point (Ctrl+click)
  if (movingPointIdx >= 0) {
    roiPoints[movingPointIdx] = [x, y];
    updateUI();
    draw();
    return;
  }

  // Dragging home plate point
  if (movingHome) {
    homePoint = [x, y];
    updateUI();
    draw();
    return;
  }

  // Dragging ball point
  if (movingBall) {
    const frame = ballFrames[ballCurrentIdx];
    ballPositions[frame.frameNum] = [x, y];
    draw();
    updateBallUI();
    return;
  }

  // Dragging machine bbox
  if (mode === 'machine' && dragging) {
    dragEnd = [x, y];
    draw();
    return;
  }

  // Hover cursor
  if (spaceHeld) {
    canvas.style.cursor = 'grab';
  } else if (e.ctrlKey || e.metaKey) {
    if (mode === 'roi' && findNearestPoint(x, y) >= 0) {
      canvas.style.cursor = 'grab';
    } else if (mode === 'home' && homePoint) {
      const dx = x - homePoint[0], dy = y - homePoint[1];
      canvas.style.cursor = Math.sqrt(dx*dx + dy*dy) <= GRAB_RADIUS / viewZoom ? 'grab' : 'crosshair';
    } else if (mode === 'ball' && isNearBallPoint(x, y)) {
      canvas.style.cursor = 'grab';
    } else {
      canvas.style.cursor = 'crosshair';
    }
  } else {
    canvas.style.cursor = 'crosshair';
  }
});

canvas.addEventListener('mousedown', e => {
  if (!img) return;
  const [sx, sy] = canvasScreenCoords(e);
  const [x, y] = canvasToImage(e);

  // Middle-click or Space+click → pan
  if (e.button === 1 || (e.button === 0 && spaceHeld)) {
    isPanning = true;
    panMouseStartX = sx;
    panMouseStartY = sy;
    panStartPanX = panX;
    panStartPanY = panY;
    canvas.style.cursor = 'grabbing';
    e.preventDefault();
    return;
  }

  // Only left-click from here
  if (e.button !== 0) return;

  // Ctrl+click: move existing point
  if (e.ctrlKey || e.metaKey) {
    if (mode === 'roi') {
      const idx = findNearestPoint(x, y);
      if (idx >= 0) {
        movingPointIdx = idx;
        canvas.style.cursor = 'grabbing';
        return;
      }
    } else if (mode === 'home' && homePoint) {
      const dx = x - homePoint[0], dy = y - homePoint[1];
      if (Math.sqrt(dx*dx + dy*dy) <= GRAB_RADIUS / viewZoom) {
        movingHome = true;
        canvas.style.cursor = 'grabbing';
        return;
      }
    } else if (mode === 'ball' && isNearBallPoint(x, y)) {
      movingBall = true;
      canvas.style.cursor = 'grabbing';
      return;
    }
  }

  // Normal click: add/set point
  if (mode === 'roi') {
    roiPoints.push([x, y]);
    updateUI();
    draw();
  } else if (mode === 'machine') {
    dragging = true;
    dragStart = [x, y];
    dragEnd = [x, y];
  } else if (mode === 'home') {
    homePoint = [x, y];
    updateUI();
    draw();
  } else if (mode === 'ball') {
    if (ballFrames.length > 0) {
      const frame = ballFrames[ballCurrentIdx];
      ballPositions[frame.frameNum] = [x, y];
      delete ballSkipped[frame.frameNum];
      draw();
      updateBallUI();
      // Auto-advance after short delay
      setTimeout(() => {
        if (ballCurrentIdx < ballFrames.length - 1) {
          showBallFrame(ballCurrentIdx + 1);
        }
      }, 150);
    }
  }
});

canvas.addEventListener('mouseup', e => {
  // Release pan
  if (isPanning) {
    isPanning = false;
    updateCursor();
    return;
  }

  // Release moved ROI point
  if (movingPointIdx >= 0) {
    movingPointIdx = -1;
    updateCursor();
    updateUI();
    draw();
    return;
  }

  // Release moved home plate point
  if (movingHome) {
    movingHome = false;
    updateCursor();
    updateUI();
    draw();
    return;
  }

  // Release moved ball point
  if (movingBall) {
    movingBall = false;
    updateCursor();
    draw();
    updateBallUI();
    return;
  }

  // Release machine bbox drag
  if (mode === 'machine' && dragging) {
    dragging = false;
    const [x, y] = canvasToImage(e);
    dragEnd = [x, y];
    const x1 = Math.min(dragStart[0], dragEnd[0]);
    const y1 = Math.min(dragStart[1], dragEnd[1]);
    const x2 = Math.max(dragStart[0], dragEnd[0]);
    const y2 = Math.max(dragStart[1], dragEnd[1]);
    if (Math.abs(x2 - x1) > 5 && Math.abs(y2 - y1) > 5) {
      machineBBox = [x1, y1, x2, y2];
    }
    dragStart = null;
    dragEnd = null;
    updateUI();
    draw();
  }
});

// Right-click to remove last ROI point
canvas.addEventListener('contextmenu', e => {
  e.preventDefault();
  if (mode === 'roi' && roiPoints.length > 0) {
    roiPoints.pop();
    updateUI();
    draw();
  } else if (mode === 'ball' && ballFrames.length > 0) {
    const frame = ballFrames[ballCurrentIdx];
    delete ballPositions[frame.frameNum];
    delete ballSkipped[frame.frameNum];
    draw();
    updateBallUI();
  }
});

// ============================================================
// DRAWING
// ============================================================
function draw() {
  // Allow draw if we have a static image OR a live stream
  if (!img && !streamActive) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw dark background
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw image using virtual camera transform
  // Use stream frame if active, otherwise static image
  const drawSource = (streamActive && streamImgReady) ? streamImg : img;
  if (!drawSource) return;

  // If streaming and no static img dimensions set, use stream dimensions
  if (streamActive && streamImgReady && !img) {
    if (imgW === 0) {
      imgW = streamImg.naturalWidth || 1920;
      imgH = streamImg.naturalHeight || 1080;
      sizeCanvas();
      resetView();
    }
  }

  const [imgScreenX, imgScreenY] = i2s(0, 0);
  const drawW = imgW * viewZoom;
  const drawH = imgH * viewZoom;
  ctx.drawImage(drawSource, imgScreenX, imgScreenY, drawW, drawH);

  // Thin border around image extent
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.strokeRect(imgScreenX, imgScreenY, drawW, drawH);

  if (mode === 'ball') {
    drawBallMode();
    return;
  }

  // Calibration overlay (pitch line, GT points)
  if (mode === 'calibrate') {
    drawCalibrationOverlay(ctx);
    drawHint();
    return;
  }

  // ROI polygon
  if (roiPoints.length > 0) {
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.setLineDash([8, 4]);
    ctx.beginPath();
    roiPoints.forEach((p, i) => {
      const [sx, sy] = i2s(p[0], p[1]);
      if (i === 0) ctx.moveTo(sx, sy);
      else ctx.lineTo(sx, sy);
    });
    if (roiPoints.length > 2) ctx.closePath();
    ctx.stroke();
    ctx.setLineDash([]);

    // Fill with semi-transparent overlay
    if (roiPoints.length >= 3) {
      ctx.fillStyle = 'rgba(0, 255, 100, 0.08)';
      ctx.beginPath();
      roiPoints.forEach((p, i) => {
        const [sx, sy] = i2s(p[0], p[1]);
        if (i === 0) ctx.moveTo(sx, sy);
        else ctx.lineTo(sx, sy);
      });
      ctx.closePath();
      ctx.fill();
    }

    // Draw vertices
    roiPoints.forEach((p, i) => {
      const [sx, sy] = i2s(p[0], p[1]);
      const isMoving = (i === movingPointIdx);
      const radius = isMoving ? 8 : 5;

      if (isMoving) {
        ctx.strokeStyle = '#00d4ff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(sx, sy, 12, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.fillStyle = isMoving ? '#00d4ff' : (i === 0 ? '#00ff88' : '#ffffff');
      ctx.beginPath();
      ctx.arc(sx, sy, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.font = '11px monospace';
      ctx.fillText(`${i + 1}`, sx + 8, sy - 4);
    });
  }

  // Machine bbox
  const bbox = machineBBox || (dragging && dragStart && dragEnd ?
    [Math.min(dragStart[0], dragEnd[0]), Math.min(dragStart[1], dragEnd[1]),
     Math.max(dragStart[0], dragEnd[0]), Math.max(dragStart[1], dragEnd[1])] : null);

  if (bbox) {
    const [sx1, sy1] = i2s(bbox[0], bbox[1]);
    const [sx2, sy2] = i2s(bbox[2], bbox[3]);
    ctx.strokeStyle = '#ff4444';
    ctx.lineWidth = 2;
    ctx.setLineDash([]);
    ctx.strokeRect(sx1, sy1, sx2 - sx1, sy2 - sy1);
    ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
    ctx.fillRect(sx1, sy1, sx2 - sx1, sy2 - sy1);
    ctx.fillStyle = '#ff4444';
    ctx.font = 'bold 12px sans-serif';
    ctx.fillText('MACHINE', sx1 + 4, sy1 - 6);
    ctx.font = '11px monospace';
    ctx.fillText(`${bbox[2] - bbox[0]}x${bbox[3] - bbox[1]}px`, sx1 + 4, sy2 + 14);
  }

  // Home plate
  if (homePoint) {
    const [sx, sy] = i2s(homePoint[0], homePoint[1]);
    ctx.fillStyle = '#ffcc00';
    ctx.strokeStyle = '#ffcc00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    const r = 10;
    ctx.moveTo(sx, sy - r);
    ctx.lineTo(sx + r, sy);
    ctx.lineTo(sx + r * 0.6, sy + r * 0.8);
    ctx.lineTo(sx - r * 0.6, sy + r * 0.8);
    ctx.lineTo(sx - r, sy);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = '#ffcc00';
    ctx.font = 'bold 12px sans-serif';
    ctx.fillText('HOME', sx + 14, sy + 4);
  }

  // Mode hint
  drawHint();
}

function drawBallMode() {
  if (ballFrames.length === 0) return;
  const frame = ballFrames[ballCurrentIdx];
  const pos = ballPositions[frame.frameNum];
  const skipped = ballSkipped[frame.frameNum];

  // Draw previous positions as faded trail
  const trailPositions = [];
  for (let i = Math.max(0, ballCurrentIdx - 10); i < ballCurrentIdx; i++) {
    const f = ballFrames[i];
    const p = ballPositions[f.frameNum];
    if (p) trailPositions.push({ pos: p, age: ballCurrentIdx - i });
  }
  if (trailPositions.length >= 2) {
    ctx.strokeStyle = 'rgba(0, 200, 0, 0.4)';
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    trailPositions.forEach((t, i) => {
      const [sx, sy] = i2s(t.pos[0], t.pos[1]);
      if (i === 0) ctx.moveTo(sx, sy);
      else ctx.lineTo(sx, sy);
    });
    if (pos) {
      const [sx, sy] = i2s(pos[0], pos[1]);
      ctx.lineTo(sx, sy);
    }
    ctx.stroke();
    ctx.setLineDash([]);
  }
  // Draw trail dots
  trailPositions.forEach(t => {
    const [sx, sy] = i2s(t.pos[0], t.pos[1]);
    const alpha = Math.max(0.15, 1 - t.age * 0.08);
    ctx.fillStyle = `rgba(0, 200, 0, ${alpha})`;
    ctx.beginPath();
    ctx.arc(sx, sy, 4, 0, Math.PI * 2);
    ctx.fill();
  });

  // Draw current ball position
  if (pos) {
    const [sx, sy] = i2s(pos[0], pos[1]);

    // Crosshair
    const ch = 20;
    ctx.strokeStyle = '#00ff88';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(sx - ch, sy); ctx.lineTo(sx + ch, sy);
    ctx.moveTo(sx, sy - ch); ctx.lineTo(sx, sy + ch);
    ctx.stroke();

    // Circle
    ctx.beginPath();
    ctx.arc(sx, sy, 12, 0, Math.PI * 2);
    ctx.stroke();

    // Center dot
    ctx.fillStyle = '#ff0000';
    ctx.beginPath();
    ctx.arc(sx, sy, 4, 0, Math.PI * 2);
    ctx.fill();

    // Label
    ctx.fillStyle = '#00ff88';
    ctx.font = 'bold 13px monospace';
    ctx.fillText(`F${frame.frameNum}: (${pos[0]}, ${pos[1]})`, sx + 18, sy - 8);
  }

  // Frame number overlay (fixed screen position)
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.fillRect(0, 0, 280, 36);
  ctx.fillStyle = '#00d4ff';
  ctx.font = 'bold 16px monospace';
  ctx.fillText(`Frame ${frame.frameNum}`, 10, 25);

  // Zoom indicator in header
  ctx.fillStyle = '#888';
  ctx.font = '11px monospace';
  ctx.fillText(`${Math.round(viewZoom * 100)}%`, 200, 25);

  // Status indicator
  if (pos) {
    ctx.fillStyle = '#00ff88';
    ctx.font = 'bold 16px monospace';
    ctx.fillText('\u2713', 250, 25);
  } else if (skipped) {
    ctx.fillStyle = '#888';
    ctx.font = 'bold 14px monospace';
    ctx.fillText('SKIP', 235, 25);
  }

  drawHint();
}

function drawHint() {
  ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.fillRect(0, canvas.height - 22, canvas.width, 22);
  ctx.fillStyle = 'rgba(0, 212, 255, 0.8)';
  ctx.font = '11px sans-serif';
  const hints = {
    roi: 'Click to add point \u2022 Ctrl+click to move \u2022 Right-click to undo \u2022 Scroll=zoom \u2022 Space+drag=pan',
    machine: 'Click & drag bounding box \u2022 Scroll=zoom \u2022 Space+drag=pan',
    home: 'Click to place \u2022 Ctrl+click to move \u2022 Scroll=zoom \u2022 Space+drag=pan',
    ball: 'Click on ball \u2022 S=skip \u2022 \u2190\u2192=navigate \u2022 Ctrl+click=move \u2022 Scroll=zoom \u2022 Space+drag=pan',
    calibrate: 'Configure camera model & cage measurements \u2022 Load Config from server \u2022 Run Auto-Calibrate with GT data',
  };
  ctx.fillText(hints[mode] || '', 10, canvas.height - 6);
}

// ============================================================
// UI UPDATES
// ============================================================
function updateUI() {
  const roiList = document.getElementById('roi-list');
  document.getElementById('roi-count').textContent = `(${roiPoints.length} points)`;
  if (roiPoints.length === 0) {
    roiList.innerHTML = 'No points yet — click on the frame';
  } else {
    roiList.innerHTML = roiPoints.map((p, i) =>
      `<div class="point">
        <span>${i + 1}. [${p[0]}, ${p[1]}]</span>
        <span class="remove" onclick="removeRoiPoint(${i})">&#10005;</span>
      </div>`
    ).join('');
  }

  const machineInfo = document.getElementById('machine-info');
  const machineStatus = document.getElementById('machine-status');
  if (machineBBox) {
    machineStatus.textContent = '(set)';
    const [x1, y1, x2, y2] = machineBBox;
    machineInfo.innerHTML = `[${x1}, ${y1}, ${x2}, ${y2}]<br>Size: ${x2 - x1}x${y2 - y1} px`;
  } else {
    machineStatus.textContent = '(not set)';
    machineInfo.innerHTML = 'Not set — drag a box around the machine';
  }

  const homeInfo = document.getElementById('home-info');
  const homeStatus = document.getElementById('home-status');
  if (homePoint) {
    homeStatus.textContent = '(set)';
    homeInfo.innerHTML = `[${homePoint[0]}, ${homePoint[1]}]`;
  } else {
    homeStatus.textContent = '(not set)';
    homeInfo.innerHTML = 'Not set — click where the batter stands';
  }

  updateJSON();
}

function updateBallUI() {
  if (ballFrames.length === 0) {
    document.getElementById('ball-frame-label').textContent = 'No frames loaded';
    document.getElementById('ball-stats').textContent = '0 / 0 frames marked';
    document.getElementById('ball-point-list').innerHTML = 'No frames loaded';
    document.getElementById('ball-json-output').textContent = '{ }';
    return;
  }

  const frame = ballFrames[ballCurrentIdx];
  document.getElementById('ball-frame-label').textContent =
    `Frame ${frame.frameNum} (${ballCurrentIdx + 1} / ${ballFrames.length})`;

  const marked = Object.keys(ballPositions).length;
  const skipped = Object.keys(ballSkipped).length;
  const total = ballFrames.length;
  document.getElementById('ball-stats').textContent =
    `${marked} marked, ${skipped} skipped, ${total - marked - skipped} remaining`;

  const pct = total > 0 ? ((marked + skipped) / total * 100) : 0;
  document.getElementById('ball-progress').style.width = pct + '%';

  const listEl = document.getElementById('ball-point-list');
  listEl.innerHTML = ballFrames.map((f, idx) => {
    const pos = ballPositions[f.frameNum];
    const skip = ballSkipped[f.frameNum];
    const isCurrent = idx === ballCurrentIdx;
    let cls = isCurrent ? 'entry current' : 'entry';
    let text = '';
    if (pos) {
      cls += ' marked';
      text = `F${f.frameNum}: [${pos[0]}, ${pos[1]}]`;
    } else if (skip) {
      cls += ' unmarked';
      text = `F${f.frameNum}: (skipped)`;
    } else {
      cls += ' unmarked';
      text = `F${f.frameNum}: —`;
    }
    const removeBtn = pos ? `<span class="remove" onclick="event.stopPropagation(); ballRemoveMark(${f.frameNum})">&#10005;</span>` : '';
    return `<div class="${cls}" data-idx="${idx}" onclick="ballGoToFrame(${idx})"><span>${text}</span>${removeBtn}</div>`;
  }).join('');

  updateBallJSON();
}

function updateJSON() {
  const output = {
    roi_polygon: roiPoints,
    calibration: {
      machine_bbox_px: machineBBox,
      home_plate_px: homePoint,
    },
  };
  document.getElementById('json-output').textContent = JSON.stringify(output, null, 2);
}

function updateBallJSON() {
  const trajectory = {};
  const sortedFrames = Object.keys(ballPositions)
    .map(Number)
    .sort((a, b) => a - b);

  sortedFrames.forEach(fn => {
    trajectory[fn] = ballPositions[fn];
  });

  document.getElementById('ball-json-output').textContent =
    JSON.stringify({ ball_positions: trajectory }, null, 2);
}

// ============================================================
// ACTIONS
// ============================================================
function removeRoiPoint(i) {
  roiPoints.splice(i, 1);
  updateUI();
  draw();
}

function undoLast() {
  if (mode === 'roi' && roiPoints.length > 0) {
    roiPoints.pop();
  } else if (mode === 'machine') {
    machineBBox = null;
  } else if (mode === 'home') {
    homePoint = null;
  } else if (mode === 'ball' && ballFrames.length > 0) {
    const frame = ballFrames[ballCurrentIdx];
    delete ballPositions[frame.frameNum];
    delete ballSkipped[frame.frameNum];
    updateBallUI();
  }
  updateUI();
  draw();
}

function clearCurrent() {
  if (mode === 'roi') roiPoints = [];
  else if (mode === 'machine') machineBBox = null;
  else if (mode === 'home') homePoint = null;
  else if (mode === 'ball') {
    ballPositions = {};
    ballSkipped = {};
    updateBallUI();
  }
  updateUI();
  draw();
}

function clearAll() {
  roiPoints = [];
  machineBBox = null;
  homePoint = null;
  ballPositions = {};
  ballSkipped = {};
  updateUI();
  updateBallUI();
  draw();
}

function copyConfig() {
  if (mode === 'ball') { copyBallJSON(); return; }
  const output = {
    roi_polygon: roiPoints,
    calibration: {
      machine_bbox_px: machineBBox,
      home_plate_px: homePoint,
      pixels_per_inch: null,
      notes: "Generated by annotate.html — paste into cage_config.json",
    },
  };
  const text = JSON.stringify(output, null, 2);
  navigator.clipboard.writeText(text).then(() => {
    alert('Config copied to clipboard!\n\nPaste the roi_polygon and calibration sections into config/cage_config.json');
  }).catch(() => {
    const ta = document.createElement('textarea');
    ta.value = text;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
    alert('Config copied to clipboard!');
  });
}

function downloadConfig() {
  if (mode === 'ball') { downloadBallJSON(); return; }
  const output = {
    roi_polygon: roiPoints,
    calibration: {
      machine_bbox_px: machineBBox,
      home_plate_px: homePoint,
      pixels_per_inch: null,
      notes: "Generated by annotate.html — paste into cage_config.json",
    },
  };
  const blob = new Blob([JSON.stringify(output, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'cage_annotations.json';
  a.click();
  URL.revokeObjectURL(url);
}

function copyBallJSON() {
  const trajectory = {};
  Object.keys(ballPositions).map(Number).sort((a, b) => a - b).forEach(fn => {
    trajectory[fn] = ballPositions[fn];
  });
  const text = JSON.stringify({ ball_positions: trajectory }, null, 2);
  navigator.clipboard.writeText(text).then(() => {
    alert(`Ball trajectory copied! (${Object.keys(trajectory).length} frames)`);
  }).catch(() => {
    const ta = document.createElement('textarea');
    ta.value = text;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
    alert('Ball trajectory copied to clipboard!');
  });
}

function downloadBallJSON() {
  const trajectory = {};
  Object.keys(ballPositions).map(Number).sort((a, b) => a - b).forEach(fn => {
    trajectory[fn] = ballPositions[fn];
  });
  const blob = new Blob([JSON.stringify({ ball_positions: trajectory }, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'ball_trajectory.json';
  a.click();
  URL.revokeObjectURL(url);
}

// ============================================================
// KEYBOARD SHORTCUTS
// ============================================================
document.addEventListener('keydown', e => {
  // Space for pan mode
  if (e.key === ' ' && !e.repeat) {
    e.preventDefault();
    spaceHeld = true;
    canvas.style.cursor = 'grab';
    return;
  }

  if (e.key === '1') setMode('roi');
  else if (e.key === '2') setMode('machine');
  else if (e.key === '3') setMode('home');
  else if (e.key === '4') setMode('ball');
  else if (e.key === '5') setMode('calibrate');
  else if (e.key === 'z' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); undoLast(); }
  else if (e.key === 'Escape') clearCurrent();
  // Zoom shortcuts
  else if (e.key === '=' || e.key === '+') { e.preventDefault(); zoomBy(1.3); }
  else if (e.key === '-') { e.preventDefault(); zoomBy(1 / 1.3); }
  else if (e.key === '0') { e.preventDefault(); resetView(); }

  // Ball tracking navigation
  if (mode === 'ball') {
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
      e.preventDefault();
      ballPrevFrame();
    } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
      e.preventDefault();
      ballNextFrame();
    } else if (e.key === 's' || e.key === 'S') {
      if (!e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        ballSkipFrame();
      }
    }
  }
});

document.addEventListener('keyup', e => {
  if (e.key === ' ') {
    spaceHeld = false;
    if (!isPanning) {
      canvas.style.cursor = 'crosshair';
    }
  }
});

// ============================================================
// WINDOW RESIZE
// ============================================================
window.addEventListener('resize', () => {
  if (img) {
    sizeCanvas();
    draw();
  }
});

// ============================================================
// CALIBRATION MODE
// ============================================================
let calCameras = null;       // camera models database
let calOptimizedParams = null; // last optimizer result
let calOverlayData = null;   // projected overlay points

// Detect if we're served by the calibration server
const calApiBase = (window.location.port === '8765' || window.location.pathname === '/') ? '' : null;

function calIsServerAvailable() {
  return calApiBase !== null;
}

async function calLoadCamerasDB() {
  if (calCameras) return;
  try {
    const resp = await fetch('/api/cameras');
    if (resp.ok) {
      calCameras = await resp.json();
      const select = document.getElementById('cal-camera-model');
      const cameras = calCameras.cameras || {};
      for (const [key, cam] of Object.entries(cameras)) {
        if (key === 'custom') continue;
        const opt = document.createElement('option');
        opt.value = key;
        opt.textContent = cam.name;
        select.appendChild(opt);
      }
    }
  } catch (e) {
    // Server not available — populate from embedded defaults
    const defaults = [
      { key: 'dji_osmo_action_3_wide', name: 'DJI Osmo Action 3 (Wide FOV)' },
      { key: 'dji_osmo_action_3_standard', name: 'DJI Osmo Action 3 (Standard FOV)' },
      { key: 'generic_action_cam', name: 'Generic Action Camera' },
    ];
    const select = document.getElementById('cal-camera-model');
    defaults.forEach(d => {
      const opt = document.createElement('option');
      opt.value = d.key;
      opt.textContent = d.name;
      select.appendChild(opt);
    });
  }
}

function onCameraModelChange() {
  const key = document.getElementById('cal-camera-model').value;
  const info = document.getElementById('cal-camera-info');
  if (!key) { info.textContent = ''; return; }

  if (calCameras && calCameras.cameras && calCameras.cameras[key]) {
    const cam = calCameras.cameras[key];
    const sensor = cam.sensor_size_mm;
    const fov = cam.fov_degrees;
    const dist = cam.distortion_coefficients || {};
    info.innerHTML = `${cam.name}<br>` +
      `Sensor: ${sensor ? sensor[0] + 'x' + sensor[1] + 'mm' : '?'}, ` +
      `Focal: ${cam.focal_length_mm || '?'}mm, ` +
      `FOV: ${fov || '?'}&deg;<br>` +
      `Distortion: k1=${dist.k1 || 0}, k2=${dist.k2 || 0}`;
  } else {
    info.textContent = key;
  }
}

async function calLoadConfig() {
  try {
    const resp = await fetch('/api/config');
    if (!resp.ok) { alert('Failed to load config: ' + resp.statusText); return; }
    const config = await resp.json();

    // Populate UI from config
    if (config.camera_model) {
      document.getElementById('cal-camera-model').value = config.camera_model;
      onCameraModelChange();
    }
    if (config.ball_type) {
      document.getElementById('cal-ball-type').value = config.ball_type;
    }
    document.getElementById('cal-mound-dist').value = config.machine_distance_ft || 60;
    if (config.calibration) {
      document.getElementById('cal-sign-speed').value = config.calibration.known_pitch_speed_mph || 47.5;
    }
    const geo = config.cage_geometry || {};
    document.getElementById('cal-cam-height').value = geo.camera_height_ft || 5;
    document.getElementById('cal-cam-behind').value = geo.camera_behind_plate_ft || 2;
    document.getElementById('cal-release-h').value = geo.release_height_ft || 3.5;
    document.getElementById('cal-strike-h').value = geo.strike_zone_height_ft || 2.5;

    document.getElementById('cal-results').textContent = 'Config loaded from server.';
  } catch (e) {
    alert('Cannot connect to calibration server.\nStart it with: python -m uvicorn scripts.calibration_server:app --port 8765');
  }
}

async function calSaveConfig() {
  const config = calBuildConfigFromUI();
  try {
    const resp = await fetch('/api/config', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ config }),
    });
    if (!resp.ok) { alert('Failed to save: ' + resp.statusText); return; }
    const result = await resp.json();
    document.getElementById('cal-results').textContent =
      'Config saved!\n' + (result.backup ? 'Backup: ' + result.backup : '');
  } catch (e) {
    alert('Cannot connect to calibration server.');
  }
}

function calBuildConfigFromUI() {
  return {
    camera_model: document.getElementById('cal-camera-model').value || undefined,
    ball_type: document.getElementById('cal-ball-type').value,
    machine_distance_ft: parseFloat(document.getElementById('cal-mound-dist').value),
    calibration: {
      known_pitch_speed_mph: parseFloat(document.getElementById('cal-sign-speed').value),
      machine_bbox_px: machineBBox,
    },
    cage_geometry: {
      camera_height_ft: parseFloat(document.getElementById('cal-cam-height').value),
      camera_behind_plate_ft: parseFloat(document.getElementById('cal-cam-behind').value),
      release_height_ft: parseFloat(document.getElementById('cal-release-h').value),
      strike_zone_height_ft: parseFloat(document.getElementById('cal-strike-h').value),
    },
  };
}

async function calRunAutoCalibrate() {
  // Need ball positions for ground truth
  const ballKeys = Object.keys(ballPositions);
  if (ballKeys.length < 3) {
    alert('Need at least 3 ball positions for auto-calibration.\nUse mode 4 (Ball Tracking) to mark ball positions in stills first.');
    return;
  }

  const gt = { ball_positions: {}, fps: 59.94 };
  ballKeys.map(Number).sort((a, b) => a - b).forEach(fn => {
    gt.ball_positions[fn] = ballPositions[fn];
  });

  const btn = document.getElementById('cal-run-btn');
  btn.textContent = 'Running...';
  btn.disabled = true;
  const results = document.getElementById('cal-results');
  results.textContent = 'Optimizing camera parameters...\nThis may take 30-60 seconds.';

  try {
    const resp = await fetch('/api/calibrate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ground_truth: gt,
        config_overrides: calBuildConfigFromUI(),
      }),
    });

    if (!resp.ok) {
      const err = await resp.text();
      results.textContent = 'Calibration failed: ' + err;
      return;
    }

    const data = await resp.json();
    calOptimizedParams = data.params;

    // Display results
    let text = '=== AUTO-CALIBRATION RESULTS ===\n\n';
    text += `Target speed: ${data.summary.target_speed_mph} mph\n`;
    text += `Mean 3D speed: ${data.summary.mean_speed_mph} mph\n`;
    text += `Mean error: ${data.summary.mean_error_pct}%\n`;
    text += `Std dev: ${data.summary.std_speed_mph} mph\n\n`;
    text += `Camera: (${data.params.camera_x_ft}, ${data.params.camera_height_ft}, -${data.params.camera_behind_plate_ft}) ft\n`;
    text += `Focal: ${data.params.focal_length_px} px\n`;
    text += `Aim: (${data.params.aim_offset_x}, ${data.params.aim_offset_y}) px\n\n`;

    text += 'Per-frame speeds:\n';
    data.frames.forEach(f => {
      text += `  F${f.frame}: ${f.speed_mph || '?'} mph (${f.error_pct > 0 ? '+' : ''}${f.error_pct || '?'}%) @ ${f.depth_ft || '?'}ft\n`;
    });

    results.textContent = text;

    // Update JSON output
    document.getElementById('cal-json-output').textContent = JSON.stringify(data.params, null, 2);

    // Refresh overlay
    draw();
  } catch (e) {
    results.textContent = 'Error: ' + e.message + '\nIs the calibration server running?';
  } finally {
    btn.textContent = 'Run Auto-Calibrate';
    btn.disabled = false;
  }
}

function calCopyParams() {
  const text = document.getElementById('cal-json-output').textContent;
  navigator.clipboard.writeText(text).then(() => {
    alert('Calibration parameters copied to clipboard!');
  }).catch(() => {});
}

// Draw calibration overlay on canvas (projected pitch line + machine outline)
function drawCalibrationOverlay(ctx) {
  if (mode !== 'calibrate') return;
  if (!document.getElementById('cal-overlay-toggle').checked) return;
  if (!calOptimizedParams) return;

  // Use a simple client-side projection for the overlay
  const p = calOptimizedParams;
  const releaseH = parseFloat(document.getElementById('cal-release-h').value) || 3.5;
  const strikeH = parseFloat(document.getElementById('cal-strike-h').value) || 2.5;
  const moundDist = parseFloat(document.getElementById('cal-mound-dist').value) || 60;

  // Project pitch line: 11 points from mound to plate
  const pitchPoints = [];
  for (let i = 0; i <= 10; i++) {
    const t = i / 10;
    const z = moundDist * (1 - t);
    const y = releaseH + t * (strikeH - releaseH);
    const x = 0;

    // Simple pinhole projection
    const dz = (z - (-p.camera_behind_plate_ft)) * 12; // to inches
    if (dz <= 0) continue;
    const dx = (x - p.camera_x_ft) * 12;
    const dy = (y - p.camera_height_ft) * 12;

    const u = p.focal_length_px * dx / dz + imgW / 2 + p.aim_offset_x;
    const v = p.focal_length_px * (-dy) / dz + imgH / 2 + p.aim_offset_y;

    pitchPoints.push({ u, v, z });
  }

  // Draw pitch line
  if (pitchPoints.length >= 2) {
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(0, 212, 255, 0.7)';
    ctx.lineWidth = 2 / viewZoom;
    ctx.setLineDash([6 / viewZoom, 4 / viewZoom]);

    const first = i2s(pitchPoints[0].u, pitchPoints[0].v);
    ctx.moveTo(first[0], first[1]);
    for (let i = 1; i < pitchPoints.length; i++) {
      const pt = i2s(pitchPoints[i].u, pitchPoints[i].v);
      ctx.lineTo(pt[0], pt[1]);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw depth markers
    pitchPoints.forEach(pt => {
      const sp = i2s(pt.u, pt.v);
      ctx.beginPath();
      ctx.arc(sp[0], sp[1], 3, 0, Math.PI * 2);
      ctx.fillStyle = pt.z > 30 ? 'rgba(0, 212, 255, 0.8)' : 'rgba(0, 255, 136, 0.8)';
      ctx.fill();

      // Label every other point
      if (Math.round(pt.z) % 12 < 2) {
        ctx.fillStyle = '#fff';
        ctx.font = `${10}px sans-serif`;
        ctx.fillText(`${Math.round(pt.z)}ft`, sp[0] + 5, sp[1] - 5);
      }
    });
  }

  // Draw ball GT positions if available
  const ballKeys = Object.keys(ballPositions);
  if (ballKeys.length > 0) {
    ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
    ballKeys.forEach(fn => {
      const [bx, by] = ballPositions[fn];
      const sp = i2s(bx, by);
      ctx.beginPath();
      ctx.arc(sp[0], sp[1], 4, 0, Math.PI * 2);
      ctx.fill();
    });
  }
}

// ============================================================
// LIVE CAMERA STREAMING
// ============================================================

function toggleStreamPanel() {
  const body = document.getElementById('stream-body');
  const arrow = document.getElementById('stream-toggle-arrow');
  const isOpen = body.classList.toggle('open');
  arrow.classList.toggle('open', isOpen);
}

function onStreamSourceChange() {
  const source = document.querySelector('input[name="stream-source"]:checked').value;
  document.getElementById('stream-usb-options').style.display = (source === 'usb') ? 'block' : 'none';
  document.getElementById('stream-rtmp-options').style.display = (source === 'rtmp') ? 'block' : 'none';
  document.getElementById('stream-start-btn').disabled = (source === 'off');

  // Auto-detect USB cameras when USB is selected
  if (source === 'usb') {
    streamDetectCameras();
  }
}

async function streamDetectCameras() {
  try {
    const resp = await fetch('/api/stream/status');
    const data = await resp.json();
    const sel = document.getElementById('stream-usb-device');
    sel.innerHTML = '';
    const cameras = data.usb_cameras || [];
    if (cameras.length === 0) {
      sel.innerHTML = '<option value="0">No cameras found (try device 0)</option>';
    } else {
      cameras.forEach(cam => {
        const opt = document.createElement('option');
        opt.value = cam.index;
        opt.textContent = `Device ${cam.index} (${cam.resolution})`;
        sel.appendChild(opt);
      });
    }
  } catch (e) {
    console.warn('Could not detect cameras:', e);
  }
}

async function streamStart() {
  const source = document.querySelector('input[name="stream-source"]:checked').value;
  if (source === 'off') return;

  const body = {source};
  if (source === 'usb') {
    body.device = parseInt(document.getElementById('stream-usb-device').value);
  } else if (source === 'rtmp') {
    body.url = document.getElementById('stream-rtmp-url').value;
  }

  document.getElementById('stream-start-btn').disabled = true;
  document.getElementById('stream-status-text').textContent = 'Starting...';

  try {
    const resp = await fetch('/api/stream/start', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(body),
    });
    const data = await resp.json();

    if (!resp.ok) {
      document.getElementById('stream-status-text').textContent = `Error: ${data.detail || 'failed'}`;
      document.getElementById('stream-start-btn').disabled = false;
      return;
    }

    // Stream is active — connect the MJPEG feed
    streamActive = true;
    streamImgReady = false;

    // Set up the hidden img to receive MJPEG stream
    streamImg.onload = function() {
      if (!streamImgReady) {
        streamImgReady = true;
        // Set image dimensions from stream if no static image loaded
        if (!img) {
          imgW = streamImg.naturalWidth;
          imgH = streamImg.naturalHeight;
          sizeCanvas();
          resetView();
          document.getElementById('placeholder').style.display = 'none';
          canvas.style.display = 'block';
        }
        document.getElementById('status-image').textContent =
          `${data.width}x${data.height} — LIVE (${source})`;
      }
      // Trigger a redraw for every new MJPEG frame
      draw();
    };
    streamImg.src = '/api/stream/feed?quality=80&t=' + Date.now();

    // Start the render loop for smooth overlay updates
    startStreamRenderLoop();

    // Update UI state
    document.getElementById('stream-dot').classList.add('active');
    document.getElementById('stream-stop-btn').disabled = false;
    document.getElementById('stream-snapshot-btn').disabled = false;
    document.getElementById('stream-status-text').textContent =
      `${data.width}x${data.height} @ ${data.nominal_fps}fps — ${data.source_info}`;

    // Start FPS polling
    startStreamFPSPoll();

  } catch (e) {
    document.getElementById('stream-status-text').textContent = `Error: ${e.message}`;
    document.getElementById('stream-start-btn').disabled = false;
  }
}

async function streamStop() {
  try {
    await fetch('/api/stream/stop', {method: 'POST'});
  } catch (e) {
    // Ignore errors on stop
  }

  streamActive = false;
  streamImgReady = false;
  streamImg.src = '';

  // Cancel render loop
  if (streamAnimFrame) {
    cancelAnimationFrame(streamAnimFrame);
    streamAnimFrame = null;
  }

  // Update UI
  document.getElementById('stream-dot').classList.remove('active');
  document.getElementById('stream-start-btn').disabled = false;
  document.getElementById('stream-stop-btn').disabled = true;
  document.getElementById('stream-snapshot-btn').disabled = true;
  document.getElementById('stream-status-text').textContent = 'Stopped';
  document.getElementById('stream-fps-badge').textContent = '';

  // Redraw with static image if available
  draw();
}

async function streamSnapshot() {
  if (!streamActive) return;

  try {
    const resp = await fetch('/api/stream/snapshot?quality=95');
    if (!resp.ok) throw new Error('Snapshot failed');
    const blob = await resp.blob();

    // Load as static image
    const url = URL.createObjectURL(blob);
    img = new Image();
    img.onload = () => {
      imgW = img.width;
      imgH = img.height;
      document.getElementById('status-image').textContent =
        `${imgW}x${imgH} — snapshot`;
      URL.revokeObjectURL(url);

      // Stop the stream so we can annotate the snapshot
      streamStop();
      sizeCanvas();
      resetView();
      draw();
    };
    img.src = url;
  } catch (e) {
    console.error('Snapshot error:', e);
  }
}

function startStreamRenderLoop() {
  // MJPEG <img> onload only fires once in most browsers (Chrome, Firefox).
  // We need a requestAnimationFrame loop to continuously redraw the canvas
  // from the MJPEG stream source while streaming is active.
  function loop() {
    if (!streamActive) {
      streamAnimFrame = null;
      return;
    }
    draw();
    streamAnimFrame = requestAnimationFrame(loop);
  }
  if (streamAnimFrame) cancelAnimationFrame(streamAnimFrame);
  streamAnimFrame = requestAnimationFrame(loop);
}

let _fpsIntervalId = null;
function startStreamFPSPoll() {
  if (_fpsIntervalId) clearInterval(_fpsIntervalId);
  _fpsIntervalId = setInterval(async () => {
    if (!streamActive) {
      clearInterval(_fpsIntervalId);
      _fpsIntervalId = null;
      return;
    }
    try {
      const resp = await fetch('/api/stream/status');
      const data = await resp.json();
      document.getElementById('stream-fps-badge').textContent =
        data.active ? `${data.measured_fps} fps` : '';
      // Detection FPS badge
      if (data.detection && data.detection.enabled) {
        document.getElementById('stream-det-fps').textContent =
          `${data.detection.detection_fps} det/s`;
      } else {
        document.getElementById('stream-det-fps').textContent = '';
      }
    } catch (e) {
      // Ignore polling errors
    }
  }, 2000);
}

async function toggleDetection(enabled) {
  try {
    const resp = await fetch('/api/stream/detection', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({enabled: enabled}),
    });
    const data = await resp.json();
    document.getElementById('stream-det-fps').textContent =
      data.enabled ? 'loading...' : '';
  } catch (e) {
    console.error('Detection toggle error:', e);
  }
}

// Initialize cameras DB when page loads
calLoadCamerasDB();

// Init
updateUI();
</script>
</body>
</html>
